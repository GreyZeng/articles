# 设计模式

作者：[Grey](https://www.cnblogs.com/greyzeng)

原文地址：

[Github](https://github.com/GreyZeng/articles/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md)

[语雀](https://www.yuque.com/greyzeng/uzfhep/gzxzch)

[博客园](https://www.cnblogs.com/greyzeng/articles/14107751.html)

## 单例模式

![UML](https://cdn.nlark.com/yuque/0/2020/png/757806/1585815368299-cf029297-38cf-493d-9e91-7155d03af486.png)

### 饿汉式

类加载的时候就会初始化这个实例, JVM保证唯一实例,线程安全， 但是可以通过反射破坏

方式一

```java
public class Singleton1 {
    private final static Singleton1 INSTANCE = new Singleton1();

    private Singleton1() {
    }

    public static Singleton1 getInstance() {
        return INSTANCE;
    }
}
```

方式二

```java
public class Singleton2 {
    private static final Singleton2 INSTANCE;

    static {
        INSTANCE = new Singleton2();
    }

    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}
```

### 懒汉式

虽然可以实现按需初始化，但是线程不安全, 因为在判断INSTANCE == null的时候，如果是多个线程操作的话， 一个线程还没有把INSTANCE初始化好，另外一个线程判断INSTANCE==null 得到true，就会继续初始化

```java


public class Singleton3 {
    private static Singleton3 INSTANCE;

    private Singleton3() {

    }

    public static Singleton3 getInstance() {
        if (INSTANCE == null) {
            // 模拟初始化对象需要的耗时操作
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            INSTANCE = new Singleton3();
        }
        return INSTANCE;
    }
}
```

为了防止线程不安全，可以在getInstance方法上加锁，这样既实现了按需初始化，又保证了线程安全，但是加锁可能会导致一些性能的问题

```java
public class Singleton4 {
    private static Singleton4 INSTANCE;

    private Singleton4() {
    }

    public static synchronized Singleton4 getInstance() {
        if (INSTANCE == null) {
            // 模拟初始化对象需要的耗时操作
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            INSTANCE = new Singleton4();
        }
        return INSTANCE;
    }
}
```

为了提升一点点性能，可以不给getInstance整个方法加锁，而是对INSTANCE判空这段代码加锁, 但是又带来了线程不安全的问题

```java
public class Singleton5 {
    private static Singleton5 INSTANCE;

    private Singleton5() {
    }

    public static Singleton5 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton5.class) {
                // 模拟初始化对象需要的耗时操作
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                INSTANCE = new Singleton5();
            }
        }
        return INSTANCE;
    }
}
```

Double Check Locking模式,就是双加锁检查模式

***这种方式中，Volatile是必需的，目的为了防止指令重排，生成一个半初始化的的实例，导致生成两个实例*** 

具体可参考 [双重检索(DCL)的思考: 为什么要加volatile?](https://blog.csdn.net/weixin_37505014/article/details/97302345) 
说了这个问题

```java
public class Singleton6 {
    private volatile static Singleton6 INSTANCE;

    private Singleton6() {
    }

    public static Singleton6 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton6.class) {
                if (INSTANCE == null) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    INSTANCE = new Singleton6();
                }
            }
        }
        return INSTANCE;
    }
}
```

以下两种更为优雅的方式，既保证了线程安全，又实现了按需加载

方式一：静态内部类方式，JVM保证单例，加载外部类时不会加载内部类，这样可以实现懒加载

```java 
public class Singleton7 {
    private Singleton7() {
    }

    public static Singleton7 getInstance() {
        return Holder.INSTANCE;
    }

    private static class Holder {
        private static final Singleton7 INSTANCE = new Singleton7();
    }

}
```

方式二： 使用枚举, 这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化,这种方式是 Effective Java 作者 Josh Bloch
提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。

```java
public enum Singleton8 {
    INSTANCE;
}
```

## UML和代码

[UML图](https://www.processon.com/view/link/5e93b9e1e0b34d6feaa65b19)

[代码](https://github.com/GreyZeng/dp)

## 参考资料

- [坦克大战-马士兵](https://ke.qq.com/course/398245)

- [菜鸟教程-设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

- [极客时间-设计模式之美-王争](https://time.geekbang.org/column/intro/250)

- [极客时间-小马哥讲Spring核心编程思想-小马哥](https://time.geekbang.org/course/intro/100042601)